# Lernnotizen

## SWTPRA_VL1_Motivation-Aufgabenstellung.pdf

- Unterschied zwischen Programm und Software:
  - einfach: Ein Programm ist kleiner als eine Software
- Softwareentwicklung
  - Ist "mehr" als Programmierung
- Softwaresysteme bestehen aus Komponenten
- Softwareprojekte sind interdisziplinär
- Prozess- bzw. Vorgehensmodelle
  - Stellen "zusammengeronnene" Erfahrung erfolgreicher Softwareprojekte dar
  - Bspw. SCRUM
  - _Wann_ ist _was_, _wie_ zu tun?
- Was braucht man für Fähigkeiten als SoftwareEntwickler?
  - Hard und Soft Skills
- Scrum:
  - stuff
    - Product Backlog enthält User Stories und Anforderungen
    - Werden priorisiert stück für stück umgesetzt
    - Priorisierung durch Dimensionen wie Risiko, Geschäftswert, Abhängigkeiten, Größe, ... basierend auf Schätzungen
    - Sprint Backlog enthält die zu erledigenden Aufgaben für den Sprint
    - Sprint Backlog ist auch Priorisiert
    - Eine Iteration ist ein Zeitraum in dem das Softwareprodukt um Funktionalität erweitert wird
    - Am Anfang eines Sprints findet ein Sprint Planning statt
    - Die Iteration wird durch ein Sprint Review und ein Sprint Retrospective abgeschlossen
    - Danach beginnt der nächste Sprint
  - roles
    - Product Owner
      - Verantwortlich für das Produkt
      - Definiert die Anforderungen
      - Priorisiert die Anforderungen
    - Scrum Master
      - Verantwortlich für die Durchführung des Scrum Prozesses
    - Team
      - Verantwortlich für die Entwicklung des Produkts

## aufgabenstellung.pdf

- Entwicklung eines "Das verrückte Labyrinth" Spiels
- Verteilte Anwendung
- Client-Server-Architektur
- Konfigurationsmöglichkeiten
  - Anzahl der Spieler
  - ...
- 2+ Spieler
- Spielfeld hat bewegliche und unbewegliche Gängekarten
  - unbewegliche sind in den Ecken und jeweils mit einem Abstand von 1 Karte wiederholt
  - unbewegliche sind außen als T oder L nach innen geordnet
  - innen drin nur L
- Es gibt Schätze auf dem Spielfeld verteilt
- Es gibt Schatzkarten, die sagen welchen Schatz man sich holen soll
- Erst: Zugreihenfolge festlegen
- Zug:
  - 1. Freie Gangkarte schieben
    - Rotation beliebig
    - Nicht da wo es rausgeschoben wurde
    - Spielfiguren, die rausgeschoben werden, werden am anderen Ende wieder reingeschoben
  - 2. Spielfigur ziehen
    - Stehen ist auch möglich
- Als Gruppe haben wir folgendes Entwickelt:
  - Server
  - Android-Spieler-Client
  - Desktop-Beobachter-Client
- Es gab ein Interface-Komitee, dass ein Protokoll designed hat
  - je Team gab es ein Mitglied, dass Teil des Komitees war
- Das ganze Ding wird mit SCRUM entwickelt
  - Das Orga-Team ist der Kunde
  - Unser Team übernimmt alle anderen Rollen
- Rollen:
  - Scrum Master
    - Koordiniert einhaltung des Scrum Prozesses
  - Product Owner
    - Definiert die Anforderungen
    - Priorisiert die Anforderungen
  - Entwickler
    - Entwickelt das Produkt
  - Qualitätsmanager
    - Überprüft die Qualität des Produkts
  - Testmanager
    - Überprüft die Funktionalität des Produkts, indem er Tests schreibt und ausführt
  - Produktmanager
    - Koordiniert Abschlusspräsentation, Messe
  - Werkzeugbeauftragter
    - Beratung bei Maven, Git, Latex, ...
  - Dokumentationsbeauftragter
    - Koordiniert die Dokumentation
- Der Tutor ist ein "2nd Tier" Scrum-Master
  - Soll Fragen klären

## SWTPRA_VL2_Angebot-Aufwandsschaetzung-Versionsmanagement.pdf

- Angebotserstellung
  - Aufwandsschätzung
  - Projektplan
  - Wir haben eine Product Vision bekommen
    - Anforderungen des Produkts aus fachlicher Sicht
    - Wesentliche Funktionen und Eigenschaften
    - technische Vorgaben
  - Aufbau des Angebots:
    - max. 5 Seiten
    - Anschreiben 1 Seite
    - Projektplan inkl. Sprint-Planung 1 Seite
    - Erklärender Text max. 3 Seiten
      - zur Aufwandsschätzung und zum Projektplan
  - Gantt chart weil cool
- Wir füllen das Backlog mit User Stories als Issues in Gitlab
- Wir verwenden GitLab milestones für die Sprints
  - Wir schätzen den Aufwand für die User Stories
- Aufwandsschätzung:
  - Teile:
    - Problemanalyse
    - Umsetzung der Funktionalität
    - Dokumentation des Features
    - Testen des Features
  - Schätzen erfordert viel Erfahrung
  - Abschätzmethoden:
    - Expertenmethode
      - Schätzung durch mehrere Experten
      - Vorteil: relativ genau
      - Nachteil: man braucht Experten
    - Analogiemethode
      - Schätzung durch Vergleich mit vergleichbaren Aufgaben
      - Vorteil: reale Basis
      - Nachteil: viel Erfahrung
      - Nachteil: nicht viele Vergleichsmöglichkeiten
      - Nachteil: subjektiv
      - Nachteil: schlecht quantifizierbar
    - Multiplikationsmethode
      - Schätzung durch zerlegung in Teilprodukte und bewertung anhand vergleichbarer Teilprodukte
      - Vorteil: es gibt wahrscheinlich schon ähnliche Teilprodukte
      - Nachteil: Bewertung erst nach der Planungsphase möglich
    - Gewichtungsmethode
      - Produktfunktionen werden kategorisiert und gewichtet
      - Es wird mit Rechenvorschriften eine Gesamtschätzung ermittelt
      - Vorteil: Schätzung in Planungsphase möglich
      - Vorteil: Schätzung ist nachvollziehbar
      - Vorteil: keine Vergleichbaren Projekte nötig
      - Vorteil: Anpassbar durch verändern der Gewichtung und Rechenvorschriften
      - Nachteil: Hoher Aufwand
      - Bspw: Function Point Methode
        - Standardisiert in ISO/IEC 20926
        - Kategorisierung
        - Komplexität
        - Jedes Kategorisierungs-Komplexitäts-Paar hat eine Gewichtung
        - Jede Funktion hat eine Kategorie und Komplexität
        - Daraus kommt der Punktewert
        - Functional size = Summe aller Punktewerte
- Musterbasierte Softwareentwicklung
  - Es geht um Patterns
    - Bspw.
      - Observer
      - Adapter
      - Command
      - Singleton
      - Strategy
  - Architektur:
    - Schichtenarchitektur
      - Präsentationsschicht
      - Logikschicht
      - Datenhaltungsschicht
    - Model-View-Controller
      - Model
      - View
      - Controller
- Versionsmanagement
  - optimistisch
    - erlaubt bearbeiten von Dateien, die gerade von jemand anderem bearbeitet werden
    - system erkennt und integriert die Änderungen
    - merge konflikte müssen manuell gelöst werden
  - pessimistisch
    - System verhindert bearbeiten von Dateien, die gerade von jemand anderem bearbeitet werden
    - Locking
  - Zentral:
    - Konflikte
    - keine offline arbeit
  - Dezentral:
    - Kann offline verwendet werden
    - Kann mergen
  - git:
    - working directory
    - index
    - local repository
    - remote repository
    - befehle:
      - add:
        - working directory -> index
      - commit:
        - index -> local repository
      - push:
        - local repository -> remote repository
      - fetch:
        - remote repository -> local repository
      - checkout:
        - local repository -> working directory
      - merge:
        - local repository -> working directory
      - pull:
        - fetch + merge
  - Git-Flow:
    - Branches:
      - master
      - develop
      - feature/topic
      - hotfix
      - release

## SWTPRA_VL3_Qualitätssicherung.pdf

- Qualitätssicherung
  - qualität
    - Produktbezogene Qualität
    - Benutzerbezogene Qualität
    - Prozessbezogene Qualität
  - Qualitätsmodell
    - Erlaubt quantifizierung der Qualität
      - Zuverlässigkeit
      - Korrektheit
      - Testbarkeit
      - Flexibilität
      - Wartbarkeit
      - Portabilität
      - Effizienz
  - Qualitätsmetrik: Ordnet einem Produkt eine Zahl zu
    - bspw.
      - LoC
      - Anzahl der Methoden, Klassen, CodeKommentarzeilen
      - Antwortzeit
      - CPU-Auslastung
      - Durchsatz
  - Qualitätsmanagement:
    - Produktorientiert
      - Du prüfst ob das Ergebnis gut oder schlecht ist
    - Prozessorientiert
      - Du legst fest, dass der Softwareentwicklungsprozess gut durchgeführt wird
    - Turns out: Mit Prozessorientiert kommt man nicht zum Ziel
    - Konstruktive QM
    - Analytische QM
    - Beispiele für Konstruktive und Produktorientierte Maßnahmen:
      - Richtlinien für Dokumenten
      - Einsatz von Java
      - Objektorientierte Entwicklung
      - Pattern-Spam
      - Modellbasierte Entwicklung
      - Werkzeuge
    - Tests sind Tests
    - Qualitätskriterien in der Definition of Done
    - Alles was messbar ist, kann hier rein
  - DevOps:
    - DevOps ist wenn die Devs und die Ops
  - Android:
    - Application
    - Activity
    - Views
    - Fragments
    - Service
    - Receiver
    - Provider
    - Intent
    - Loader

## Protokoll_1_1_4.pdf

- Tile:
  - Orientation
  - Typ (I,L,T)
  - Contains
    - Nothing {}
    - Treasure: treasure
    - startNumber start
- Field:
  - tiles: Tile[][]
  - height
  - width
- Position:
  - x
  - y
- Push
  - fromDirection: Orientation
  - index
  - orientation: Orientation
- GamePlayer:
  - username
  - points
  - position
  - collectedTreasures
- LobbyPlayer:
  - username
  - points
- Orientation:
  - North
  - East
  - South
  - West
- Treasure: Einfach nur die ID
- GameState
  - gameId
  - field
  - players
  - parameters
  - freeTile
  - phase
- Phase
  - notStarted
  - running:
    - currentPlayer
    - currentRound
    - currentAction
    - personalTreasureCard
    - currentGameTime
  - paused
    - currentPlayer
    - currentRound
    - currentAction
    - personalTreasureCard
    - currentGameTime
  - finished
    - winner
    - gameTime
  - aborted: {}
- gameParameters
  - neededTreasures
  - pointsPerTreasure
  - pointsForReachingStartPosition
  - visualisationTime
  - maxTurnTime
  - penaltyType
  - maxGameTime
  - maxTurnsPerPlayer
- Konfigurationsdatei:
  - field:
    - width
    - height
  - players: Position[]
  - parameters: GameParameters
- runtime Messages:
  - hello (server -> client)
    - hello:
      - version
      - tournamentMode
  - observer login (client -> server)
    - loginObserver: {}
  - player login (client -> server)
    - loginPlayer:
      - username
  - Antworten
    - typ login
    - usernameAlreadyTaken
    - usernameInvalid
    - loginNotPermited
  - lobby holen (client -> server)
    - getLobby: {}
  - lobby antwort (server -> client)
    - lobby: LobbyPlayer[]
  - game liste holen (client -> server)
    - getGameList: {}
  - game liste antwort (server -> client)
    - gameList: GameState[]
  - spiel beitreten (client -> server)
    - joinGame:
      - gameId
  - spiel beitreten antwort (server -> client)
    - fehler:
      - gameNotFound
      - gameFull
      - gameAlreadyStarted
      - joinNotPermitted
    - erfolg:
      - GameStateMessage
  - spiel beobachten (client -> server)
    - observeGame:
      - gameId
  - gamestate holen (client -> server)
    - getGameState: {}
  - gamestate antwort (server -> client)
    - gameState: GameState
  - spieler betritt spiel (server -> client)
    - playerJoined:
      - username
      - startingPosition
  - spieler verlässt spiel (server -> client)
    - playerLeft:
      - username
  - get remaining time (client -> server)
    - getRemainingTime: {}
  - remaining time (server -> client)
    - remainingTime: number
  - beobachter verlässt spiel (client -> server)
    - leaveGame: {}
  - feld wurde gepusht: (server -> client)
    - pushed
      - fromDirection
      - index
      - orientation
    - moved
      - playerUsername
      - position
      - nextPlayerUsername
      - newPoints
  - feld wird gepusht (client -> server)
    - push: Push
    - move: Position
  - du hast eine Neue Schatzkarte bekommen (server -> client)
    - newCard: number (Treasure)
  - Sonstiges:
    - ping (bidirectional)
      - ping:
        - time: number
      - pong:
        - time: number
    - allgemeines response
      - response:
        - success: true
        - request: string
      - response:
        - success: false
        - request: string
        - error: string
